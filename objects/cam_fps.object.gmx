<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_cam</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>texture_set_repeat(true);
//wsize=170
//hsize=100
wsize=145
hsize=0

es = CAM_EYESEP; //Eye seperation (in CM, from the nose)


event_user(0); // Initialize the surfaces

aspect = view_wview/view_hview;




</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>es+=keyboard_check(vk_up)*.1;
es-=keyboard_check(vk_down)*.1;

yaw = OVR_Device_getYaw();
pitch = OVR_Device_getPitch();
roll = OVR_Device_getRoll();
/*
xadd=lengthdir_x_3d(yaw+90,roll,es/2);
yadd=lengthdir_y_3d(yaw+90,roll,es/2);
zadd=lengthdir_z_3d(yaw+90,roll,es/2);
*/

direction = yaw+player_fps.dir //Direction the camera is facing (body direction + head direction)

r = es/2
hdir = direction;
vdir = roll;

xadd = r*cos(degtorad(hdir))*cos(degtorad(vdir));
yadd = -r*sin(degtorad(hdir))*cos(degtorad(vdir));
zadd = r*sin(degtorad(vdir));


//Update the sound position
audio_listener_position(player_fps.x,player_fps.y,player_fps.z+player_fps.height)
audio_listener_orientation(-xadd*100,-yadd*100,zadd*100,0,0,40);
//updateAudioListener(player_fps.x,player_fps.y,player_fps.z+player_fps.height,direction,0);
//audio_listener_orientation(xt, yt, zt, 0, 0, 0)
// The orientation should be fixed together with the eyes.

if (!surface_exists(global.SURFACE[SURF_RIGHT])) {
    event_user(0);
}

//Draw the left eye on a surface
surface_set_target(global.SURFACE[SURF_LEFT]);
    draw_clear_alpha(c_black,0);
    aspect = (view_wview/2)/view_hview;
    var c_roll=lengthdir_x(90,roll);
    xfrom = player_fps.x+xadd;
    yfrom = player_fps.y+yadd;
    zfrom = player_fps.z + player_fps.height+zadd;
    
    d3d_set_projection_simple(xfrom,yfrom,zfrom,direction,pitch,roll, CAM_ANGLE, aspect, CAM_ZNEAR, CAM_ZFAR);
    
    //shader_set(stereo_offset_left);//use this to offset everything for the current ee view
    draw3DWorld();
    d3d_transform_set_identity();
    //shader_reset();
    //d3d_transform_set_identity()
    
//Draw the right eye on a surface
surface_set_target(global.SURFACE[SURF_RIGHT]);  
    draw_clear_alpha(c_black,0);
    aspect = (view_wview/2)/view_hview;
    var c_roll=lengthdir_x(90,roll);
    xfrom = player_fps.x-xadd;
    yfrom = player_fps.y-yadd;
    zfrom = player_fps.z + player_fps.height-zadd;
    d3d_set_projection_simple(xfrom,yfrom,zfrom,direction,pitch,roll, CAM_ANGLE, aspect, CAM_ZNEAR, CAM_ZFAR);

    //shader_set(stereo_offset_right);//use this to offset everything for the current ee view
    draw3DWorld();
    d3d_transform_set_identity();
    //shader_reset();
    //d3d_transform_set_identity()

//Go back to regular drawing and show the surfaces
surface_reset_target();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Draw everything on the regular surface
//surface_set_target(global.SURFACE[SURF_REGULAR]);
    draw_clear(c_black);
    d3d_set_projection_ortho(0,0,view_wview,view_hview,0);
            
    //draw_surface_stretched_ext(global.SURFACE[SURF_LEFT],0,0,view_wview/2,view_hview,c_white,1);
    //draw_surface_stretched_ext(global.SURFACE[SURF_RIGHT],view_wview/2,0,view_wview/2,view_hview,c_white,1);
    
    spr_TextureLeft = surface_get_texture(global.SURFACE[SURF_RIGHT]);
    spr_TextureRight = surface_get_texture(global.SURFACE[SURF_LEFT]);
    
    shader_set(hmdwarp_shader);
    //must use this shader to warp the image to counteract the fisheye lenses
    
    texture_set_stage(passedTextureLeft, spr_TextureLeft);
    texture_set_stage(passedTextureRight, spr_TextureRight);
    draw_sprite_stretched(blank_spr,0,0,0,view_wview,view_hview)
    
    shader_reset();
    
//surface_reset_target();

/*
// Now draw the regular surface
d3d_set_projection_ortho(0,0,view_wview,view_hview,0);
draw_clear(c_black);

//draw_sprite_stretched(blank_spr,0,0,50,view_wview,view_hview-100)
*/

//draw_surface_stretched_ext(global.SURFACE[SURF_LEFT],0,50,view_wview,view_hview-100,c_white,1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>8,8</point>
    <point>8,8</point>
  </PhysicsShapePoints>
</object>
