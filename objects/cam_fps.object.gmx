<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>OVR_Init();

//wsize=170
//hsize=100
wsize=145
hsize=0

es = CAM_EYESEP; //Eye seperation (in CM, from the nose)

passedTextureLeft = shader_get_sampler_index(hmdwarp_shader, "passedTextureLeft")
passedTextureRight = shader_get_sampler_index(hmdwarp_shader, "passedTextureRight")

event_user(0); // Initialize the surfaces

aspect = view_wview/view_hview;

yaw=0;
pitch=0;
roll=0;

xfrom = player_fps.x;
yfrom = player_fps.y;
zfrom = player_fps.z + player_fps.height;

// @todo 
// Check out initShaderMatrixArray. I just don't know how to get those arrays into the shaders.
// initShaderMatrixArray(3);

//rightMat
rightMat[0] = 1;
rightMat[1] = 0;
rightMat[2] = 0;
rightMat[3] = -1;

rightMat[4] = 0;
rightMat[5] = 1;
rightMat[6] = 0;
rightMat[7] = 0;

rightMat[8] = 0;
rightMat[9] = 0;
rightMat[10] = 1;
rightMat[11] = 0;

rightMat[12] = 0;
rightMat[13] = 0;
rightMat[14] = 0;
rightMat[15] = 1; // GM Matrix has to have 0-15, can't be a 2-dimension array

//rmat = shader_get_uniform(stereo_offset_right, "rightMat");

//leftMat
leftMat[0] = 1;
leftMat[1] = 0;
leftMat[2] = 0;
leftMat[3] = 0;

leftMat[4] = 0;
leftMat[5] = 1;
leftMat[6] = 0;
leftMat[7] = 0;

leftMat[8] = 0;
leftMat[9] = 0;
leftMat[10] = 1;
leftMat[11] = 0;

leftMat[12] = 0;
leftMat[13] = 0;
leftMat[14] = 0;
leftMat[15] = 1; // GM Matrix has to have 0-15, can't be a 2-dimension array

//lmat = shader_get_uniform(stereo_offset_left, "leftMat");

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="7" enumb="10">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>global.SURFACE[SURF_RIGHT]=surface_create(view_wview/2,view_hview);
global.SURFACE[SURF_LEFT]=surface_create(view_wview/2,view_hview);
global.SURFACE[SURF_REGULAR]=surface_create(view_wview,view_hview);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>
//es+=keyboard_check(vk_up)*.1
//es-=keyboard_check(vk_down)*.1

hsize+=keyboard_check(vk_up)*5
hsize-=keyboard_check(vk_down)*5

wsize+=keyboard_check(vk_right)*5
wsize-=keyboard_check(vk_left)*5



yaw = OVR_Device_getYaw();
player_fps.dir = yaw;
pitch = OVR_Device_getPitch();
roll = OVR_Device_getRoll();

    if (!surface_exists(global.SURFACE[SURF_RIGHT])) {
        event_user(0);
    }

    //Draw the left eye on a surface
    surface_set_target(global.SURFACE[SURF_LEFT]);
        draw_clear(background_color);
        aspect = (view_wview/2)/view_hview;
        xfrom = player_fps.x//-lengthdir_x(es,player_fps.dir-90);
        yfrom = player_fps.y//-lengthdir_y(es,player_fps.dir-90);
        zfrom = player_fps.z + player_fps.height;
        
        d3d_set_projection_simple(xfrom,yfrom,zfrom,yaw,pitch,roll, CAM_ANGLE, aspect, CAM_ZNEAR, CAM_ZFAR);
        
        shader_set(stereo_offset_left);//use this to offset everything for the current ee view
        with obj_room {
            event_perform(ev_draw,0);
        }
        shader_reset();
        d3d_transform_set_identity()
        
    //Draw the right eye on a surface
    surface_set_target(global.SURFACE[SURF_RIGHT]);        
        draw_clear(background_color);
        aspect = (view_wview/2)/view_hview;
        xfrom = player_fps.x//+lengthdir_x(es,player_fps.dir-90);
        yfrom = player_fps.y//+lengthdir_y(es,player_fps.dir-90);
        zfrom = player_fps.z + player_fps.height;
        d3d_set_projection_simple(xfrom,yfrom,zfrom,yaw,pitch,roll, CAM_ANGLE, aspect, CAM_ZNEAR, CAM_ZFAR);
       
        shader_set(stereo_offset_right);//use this to offset everything for the current ee view
        with obj_room {
            event_perform(ev_draw,0);
        }
        shader_reset();
        d3d_transform_set_identity()

    //Go back to regular drawing and show the surfaces
    surface_reset_target();
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Draw everything on the regular surface
surface_set_target(global.SURFACE[SURF_REGULAR]);
    draw_clear(c_black);
    d3d_set_projection_ortho(0,0,view_wview,view_hview,0);
            
    //draw_surface_stretched_ext(global.SURFACE[SURF_LEFT],0,0,view_wview/2,view_hview,c_white,1);
    //draw_surface_stretched_ext(global.SURFACE[SURF_LEFT],120+840,85,840,906,c_white,1);
    
    spr_TextureLeft = surface_get_texture(global.SURFACE[SURF_RIGHT]);
    spr_TextureRight = surface_get_texture(global.SURFACE[SURF_LEFT]);
    
    shader_set(hmdwarp_shader);
    //must use this shader to warp the image to counteract the fisheye lenses
    
    texture_set_stage(passedTextureLeft, spr_TextureLeft);
    texture_set_stage(passedTextureRight, spr_TextureRight);
    draw_sprite_stretched(blank_spr,0,0,0,view_wview,view_hview)
    
    shader_reset();
    
surface_reset_target();

// Now draw the regular surface
d3d_set_projection_ortho(0,0,view_wview,view_hview,0);
draw_clear(c_black);

draw_surface_stretched_ext(global.SURFACE[SURF_REGULAR], wsize, hsize, view_wview-wsize*2, view_hview-hsize*2,c_white,1);
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
